# 操作系统实验：模拟分页虚拟地址与页面置换算法

## 需求分析

页面置换算法的基本内容

1.1 页面置换算法是在当进程运行过程中，若其要访问的页面不在内存且内存已满时，要决定将哪个页面换出的算法。常见的页面置换算法包括最佳置换、先进先出置换、最近最久未使用置换和Clock置换等。本次的实验实现的算法包括最佳置换算法（OPT）、先进先出置换算法（FIFO）和最近最久未使用算法（LRU）。

1.2 页面置换算法涉及到一些概念如下： 缺页率：当需要访问的页面不在内存时称为缺页，此时需要将页面调入内存。缺页率就是要访问的页面不在内存中的概率。因此缺页率=缺页次数/要访问的页面总数。需要注意的是，缺页的时候不一定需要进行页面置换（如果内存还没满，直接将页面调入内存即可）。

置换率：置换就是将旧页面调出内存，新页面调进内存，即新页面代替旧页面的过程。置换率就是需要进行页面置换的概率。所以置换率=置换次数/要访问的页面总数。

命中率：就是要访问的页面恰好在内存中的概率。可以发现（缺页率+命中率=1）

## 总体设计

### 结构设计

#### 分页虚拟地址

在本次实验中，主要是分为以下几个大类的结构设计：

- 模拟资源
  - 模拟内存
  - 模拟磁盘
- 模拟进程
- 调度处理类

总体页表虚拟地址结构如下图：

<div>
    <center>
    <img src=".\pics\xmind\页表机制仿真.png"
         alt="pic error"
         style="zoom:100%"/>
    <br>
	<text>页表机制仿真<text/>
    </center>
</div>

#### 页面置换算法

总体页表置换算法结构如下图：

<div>
    <center>
    <img src=".\pics\xmind\页面置换算法.png"
         alt="pic error"
         style="zoom:100%"/>
    <br>
	<text>页面置换算法<text/>
    </center>
</div>



### 逻辑设计
<div>
    <center>
    <img src=".\pics\process\初始化过程.png"
         alt="pic error"
         style="zoom:75%"/>
    <br>
	<text>初始化过程<text/>
    </center>
</div>

<div>
    <center>
    <img src=".\pics\process\运行过程.png"
         alt="pic error"
         style="zoom:75%"/>
    <br>
	<text>运行过程<text/>
    </center>
</div>

<div>
    <center>
    <img src=".\pics\process\展示流程.png"
         alt="pic error"
         style="zoom:75%"/>
    <br>
	<text>展示流程<text/>
    </center>
</div>



## 详细设计

## 算法设计

### 先进先出算法（First-In First-Out, FIFO）

思路：选择在内存驻留时间最长的页面进行置换

实现：维护一个记录所有位于内存中的逻辑页面链表，链表元素按驻留内存的时间排序，链首最长，链尾最短，出现缺页时，选择链首页面进行置换，新页面加到链尾

特点：实现简单；性能较差，调出的页面可能是经常访问的

`Belady`异常：当为进程分配的物理块数增大时，缺页次数不减反增。

### 最近最久未使用算法 (Least Recently Used, LRU)

思路：选择最长时间没有被引用的页面进行置换，因为如果某些页面长时间未被访问，则它们在将来还可能会长时间不会访问

实现：缺页时，**计算内存中每个逻辑页面的上一次访问时间，选择上一次使用到当前时间最长的页面**

特点：可能达到最优的效果，维护这样的访问链表开销比较大

**在缺页中断发生时，置换未使用时间最长的页面。**

LRU理论上是可以实现的，但是代价很高。维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。

假设用硬件实现：

- 硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问完内存后，将当前的C值保存到被访问页面的页表项中。
- 一旦发生缺页中断，操作系统就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面。
- 但是只有非常少的计算机拥有这样的硬件

### 最不常用算法（Least Frequently Used, LFU）

思路：缺页时，置换访问次数最少的页面

实现：每个页面设置一个访问计数，访问页面时，访问计数加1，缺页时，置换计数最小的页面

特点：算法开销大，开始时频繁使用，但以后不使用的页面很难置换

### 时钟置换算法（Clock）

思路：仅对页面的访问情况进行大致统计

实现：

- 在页表项中增加访问位，描述页面在过去一段时间的内访问情况。
- 将各页面组织成环形链表，指针指向最先调入的页面。
- 访问页面时，在页表项记录页面访问情况。（就是如果访问过了，就设置为1）.
- 缺页时，从指针处开始顺序查找未被访问的页面进行置换。（进行一次遍历，如果该位为1，则修改该位为0，进行下一个判断。）

特点：时钟算法是LRU和FIFO的折中

基于算法特性，第二轮扫描中一定会有为0的页表项，所以最多会进行两轮扫描。

### 改进型时钟置换算法（Advanced Clock）

时钟算法没有考虑页是否被修改过，对于同等情况下，为了减少写外存，没有被修改的页要被优先丢弃。

所以我们又加上了修改位，（0，没有，1，有）。

进行四轮扫描：

1. 查找是否有没有被访问，又没有修改的页。（不修改标志
2. 查找（0，1），修改访问位。
3. 查找（0，0），不修改。
4. 查找（0，1），一定找到，不修改。

## 程序测试

## 运行结果

## 心得总结

根据实验结果可以看出，对同一种算法，对于不同的访问序列，其缺页率是不同，会有所变化。总的来看，最佳置换算法的缺页率是最低的，然后页面缓冲算法的缺页率要低于其他置换算法。改进型clock算法稍微好于先进先出算法和最近最久未使用算法。先进先出算法和最近最久未使用算法性能相近。

同时对比不同内存块数下的程序运行结果能够看出，算法的缺页率与分配的内存块数有关系，分配的内存块数越多，缺页率越低。
